{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"About AI Driver Note","text":"<p>Note: This is a draft document and is still being written.</p> <p>This document primarily serves to record insights and notes gathered while using Azure OpenAI, with a focus on practical applications. Specifically, a CLI tool built with Python will be integrated into the Azure DevOps Pipeline to assist with Code Review tasks. The document is organized into three sections that cover Azure OpenAI, the CLI Tool, and Azure DevOps configuration.</p>"},{"location":"#azure-openai","title":"Azure OpenAI","text":"<p>This section introduces the methods for calling the Azure OpenAI API.</p>"},{"location":"#cli-tool","title":"CLI Tool","text":"<p>This section explains how to develop a CLI tool using Python.</p>"},{"location":"#azure-devops","title":"Azure DevOps","text":"<p>This section covers how to store the CLI tool in Azure DevOps Artifacts and configure the Azure DevOps Pipeline to execute the CLI tool.</p>"},{"location":"azure-devops/cli-artifacts/","title":"CLI Deployment","text":"<p>Using a CLI for AI-assisted software development is an effective approach. It not only allows local execution but also facilitates broader use through CI/CD pipelines or as a VS Code extension.</p> <p>This article primarily documents the process of deploying the CLI to Azure DevOps Artifacts, with special emphasis on properly configuring permissions.</p>"},{"location":"azure-devops/cli-artifacts/#1-deployment-overview","title":"1. Deployment Overview","text":"<p>Deploying a CLI to Azure DevOps Artifacts allows it to be shared and used by multiple teams or projects. This process requires careful permission management to ensure that the deployment and access are both secure and efficient.</p>"},{"location":"azure-devops/cli-artifacts/#2-required-permissions","title":"2. Required Permissions","text":""},{"location":"azure-devops/cli-artifacts/#21-feed-permissions","title":"2.1 Feed Permissions","text":"<p>To deploy the CLI to Azure DevOps Artifacts, you need to properly configure permissions for the feed where the artifacts will be published. Here are the necessary steps:</p> <ul> <li>Manage Feed Permissions: Navigate to Artifacts in Azure DevOps, select the desired feed, and click on the gear icon to enter Feed Settings. In the Permissions tab, add the Project Collection Build Service account if it is not already listed, and grant it Contributor permissions to allow publishing and managing packages.</li> </ul>"},{"location":"azure-devops/cli-artifacts/#22-pipeline-configuration","title":"2.2 Pipeline Configuration","text":"<p>In the pipeline configuration, use the following steps to ensure the CLI is successfully deployed to Azure DevOps Artifacts:</p> <ol> <li> <p>Access Feed Settings:</p> </li> <li> <p>Navigate to Artifacts in Azure DevOps, select the desired feed, and configure permissions using the gear icon to allow the Project Collection Build Service to publish packages.</p> </li> <li> <p>Pipeline Task for Deployment:</p> </li> <li> <p>Use the following YAML task to publish the CLI to Azure Artifacts:</p> </li> </ol> <p><code>yaml    steps:    - task: npm@1      inputs:        command: 'publish'        publishRegistry: 'useFeed'        publishFeed: 'your-feed-id'        workingDir: '$(System.DefaultWorkingDirectory)'</code></p> <ul> <li>Explanation of each input parameter:<ul> <li>command: Sets the npm command. Here, 'publish' is used to indicate publishing the package to the registry.</li> <li>publishRegistry: Specifies the registry to use. 'useFeed' here indicates using an internal registry in Azure Artifacts.</li> <li>publishFeed: Specifies the ID of the registry to publish to. This needs to be replaced with the actual registry identifier.</li> <li>workingDir: Sets the working directory. <code>$(System.DefaultWorkingDirectory)</code> is the default working directory of the pipeline, usually containing the generated package files.</li> </ul> </li> </ul>"},{"location":"azure-devops/cli-artifacts/#3-summary","title":"3. Summary","text":"<p>Deploying the CLI to Azure DevOps Artifacts involves setting up the correct permissions for the Project Collection Build Service account and configuring the pipeline to publish the package. Make sure the appropriate permissions are configured at the feed level to allow successful deployment. Proper permission management is crucial to ensure a smooth deployment process and secure access to the published CLI. Feed permissions are managed through the Artifacts section by accessing the feed settings and configuring permissions through the gear icon.</p>"},{"location":"azure-devops/pipeline-permission/","title":"Pipeline Permissions","text":"<p>In this section, we will explain how to configure the necessary permissions in Azure Pipelines to ensure that the pipeline can successfully perform commit and push operations. This guide will help you understand how to use appropriate permissions and settings to enable the pipeline to automate these tasks.</p> <p>If permissions are not configured correctly, you may encounter the following error message:</p> <pre><code>remote: TF401027: You need the Git 'GenericContribute' permission to perform this action. Details: identity 'Build\\7be59e48-a479-XXXX-a453-XXXXXXXXXXXX', scope 'repository'.\n</code></pre> <p>In this case, you can copy the GUID (7be59e48-a479-XXXX-a453-XXXXXXXXXXXX) from the error message and search for it in Azure DevOps to configure the required permissions. Detailed steps on how to do this are included below.</p>"},{"location":"azure-devops/pipeline-permission/#1-permissions-required","title":"1. Permissions Required","text":"<p>To automate commit and push operations, you typically need to configure specific permissions to allow the pipeline to make changes to the repository. Here are some essential steps and settings:</p>"},{"location":"azure-devops/pipeline-permission/#11-build-service-account","title":"1.1 Build Service Account","text":"<p>The {Project-Name} Build Service account is a project-level service account automatically created by Azure DevOps for each project. When the pipeline performs operations related to the code, it usually uses this account. To allow the pipeline to perform commit and push operations, you need to configure the following permissions for this account:</p> <ul> <li>Contribute: Allows committing and pushing changes.</li> <li>Bypass policies when pushing (if branch protection policies are set): Allows bypassing branch policies to push changes directly.</li> </ul>"},{"location":"azure-devops/pipeline-permission/#12-persistcredentials-setting","title":"1.2 PersistCredentials Setting","text":"<p>In the pipeline's checkout step, you also need to configure the following setting to ensure that subsequent Git operations can use the appropriate credentials:</p> <pre><code>steps:\n- checkout: self\n  persistCredentials: true  # Keep credentials for subsequent Git operations\n</code></pre> <ul> <li><code>persistCredentials: true</code>: Retains the credentials for subsequent Git operations. This ensures that after the checkout is complete, the pipeline can still perform commit and push operations without needing to re-authenticate.</li> </ul>"},{"location":"azure-devops/pipeline-permission/#2-setup-steps","title":"2. Setup Steps","text":""},{"location":"azure-devops/pipeline-permission/#21-build-service-permissions","title":"2.1 Build Service Permissions","text":"<ol> <li> <p>Access Project Settings:</p> </li> <li> <p>In Azure DevOps, go to Project Settings and select Repositories.</p> </li> <li> <p>Select Security Settings:</p> </li> <li> <p>Under Repositories &gt; Security, find the {Project-Name} Build Service account. If the account is not listed, use the search function to locate the Build Service account.</p> </li> <li> <p>Configure Contribute Permission:</p> </li> <li> <p>Set the Contribute and Contribute to pull requests permission to Allow to enable the pipeline to push and merge changes.</p> </li> </ol>"},{"location":"azure-devops/pipeline-permission/#22-persistent-credentials","title":"2.2 Persistent Credentials","text":"<p>In the pipeline configuration, use <code>persistCredentials: true</code> to retain credentials so that Git operations can continue after the checkout.</p>"},{"location":"azure-devops/pipeline-permission/#3-summary","title":"3. Summary","text":"<p>To enable Azure Pipelines to automate commit and push operations, you need to configure the {Project-Name} Build Service account with Contribute permission and set <code>persistCredentials: true</code> in the checkout step. These settings ensure that the pipeline has sufficient permissions to modify the repository during the automation process.</p> <p>The file name <code>pipeline-permission.md</code> is concise and clear, suitable for describing all settings related to pipeline permissions, not only for commits and pushes but also for future permission configurations.</p>"},{"location":"azure-openai/azure-openai/","title":"Azure OpenAI","text":""},{"location":"azure-openai/azure-openai/#1-overview","title":"1. Overview","text":"<p>Azure OpenAI is a collaboration between Microsoft Azure and OpenAI, providing access to powerful language models like GPT-4 and Codex on Azure\u2019s secure cloud platform. This service enables developers to build applications such as chatbots, automated customer service, content generation, and more.</p>"},{"location":"azure-openai/azure-openai/#11-key-advantages","title":"1.1 Key Advantages","text":"<ul> <li>Security and Compliance: Enterprise-grade security with Azure compliance certifications.</li> <li>Scalability: Horizontally scalable to meet application needs.</li> <li>Seamless Integration: Direct integration with Azure services, including Cognitive Services and Data Factory.</li> </ul>"},{"location":"azure-openai/azure-openai/#2-getting-started","title":"2. Getting Started","text":""},{"location":"azure-openai/azure-openai/#21-requirements","title":"2.1 Requirements","text":"<ol> <li>Azure Subscription: Required to activate the service.</li> <li>Access Permissions: Specific permissions may be needed for service usage.</li> </ol>"},{"location":"azure-openai/azure-openai/#22-setup","title":"2.2 Setup","text":"<ol> <li> <p>Create Resource:</p> <ul> <li>Sign in to the Azure portal, search for \"Azure OpenAI,\" and create a new resource.</li> <li>Configure resource name, region, and pricing plan.</li> </ul> </li> <li> <p>Select Model:</p> <ul> <li>Choose the appropriate model (e.g., GPT-4 or Codex) on the resource page.</li> <li>Configure model parameters as needed (e.g., response length, quality).</li> </ul> </li> <li> <p>Get API Key:</p> <ul> <li>Generate your API Key from the Azure portal and save it to an environment variable on your local machine or container.</li> </ul> </li> </ol>"},{"location":"azure-openai/azure-openai/#3-using-azure-openai-api","title":"3. Using Azure OpenAI API","text":""},{"location":"azure-openai/azure-openai/#31-chat-vs-non-chat-mode","title":"3.1 Chat vs Non-Chat Mode","text":"<p>Azure OpenAI supports both Chat and Non-Chat modes, each suited for different scenarios.</p>"},{"location":"azure-openai/azure-openai/#311-chat-mode","title":"3.1.1 Chat Mode","text":"<ul> <li>Use Case: Ideal for conversational interactions that require context management, such as chatbots.</li> <li>How It Works: Each request includes a message list (<code>messages</code>) with past interactions and user inputs.</li> </ul> <pre><code>from azure.identity import DefaultAzureCredential\nfrom azure.ai.openai import OpenAIClient\n\n# Set up Azure OpenAI parameters\nAZURE_OPENAI_ENDPOINT = \"https://&lt;your Azure OpenAI endpoint&gt;.openai.azure.com/\"\nAZURE_OPENAI_API_KEY = \"&lt;your API Key&gt;\"\n\n# Initialize OpenAIClient\nclient = OpenAIClient(\n    endpoint=AZURE_OPENAI_ENDPOINT, \n    credential=AZURE_OPENAI_API_KEY\n)\n\n# Set up model deployment name and request content\ndeployment_id = \"&lt;your deployment name&gt;\" \nmessages = [\n    {\"role\": \"system\", \"content\": \"You are an assistant.\"},\n    {\"role\": \"user\", \"content\": \"Describe AI's future in three sentences.\"}\n]\n\n# Call the API to get a response\nresponse = client.chat_completions.create(\n    deployment_id=deployment_id,\n    messages=messages,\n    max_tokens=50\n)\n\n# Display the API response result\nprint(response.choices[0].message[\"content\"].strip())\n</code></pre>"},{"location":"azure-openai/azure-openai/#312-non-chat-mode","title":"3.1.2 Non-Chat Mode","text":"<ul> <li>Use Case: Suitable for single-response interactions or content generation without context tracking.</li> <li>How It Works: Uses a <code>prompt</code> parameter to supply input without context handling.</li> </ul> <pre><code>from azure.identity import DefaultAzureCredential\nfrom azure.ai.openai import OpenAIClient\n\n# Set up Azure OpenAI parameters\nAZURE_OPENAI_ENDPOINT = \"https://&lt;your Azure OpenAI endpoint&gt;.openai.azure.com/\"\nAZURE_OPENAI_API_KEY = \"&lt;your API Key&gt;\"\n\n# Initialize OpenAIClient\nclient = OpenAIClient(\n    endpoint=AZURE_OPENAI_ENDPOINT, \n    credential=AZURE_OPENAI_API_KEY\n)\n\n# Set up model name and request content\ndeployment_id = \"&lt;your deployment name&gt;\"  \nprompt = \"Describe AI's future in three sentences.\"\n\n# Call the API to get a response\nresponse = client.completions.create(\n    deployment_id=deployment_id,\n    prompt=prompt,\n    max_tokens=50\n)\n\n# Display the API response result\nprint(response.choices[0].text.strip())\n</code></pre>"},{"location":"azure-openai/azure-openai/#313-choosing-modes","title":"3.1.3 Choosing Modes","text":"<p>Chat Mode is best for interactions needing context retention, while Non-Chat Mode is suitable for one-off responses, Q&amp;A, or generation tasks. When the chat's messages only include a single user content, there is little difference between chat and non-chat modes.</p> <p>In Chat Mode, if the number of messages becomes too large, it is important to summarize the conversation appropriately to avoid generating too many tokens. Here are some strategies to condense previous conversations:</p> <ol> <li>Summarize Key Points: Extract the main ideas and key points from the previous messages and create a concise summary.</li> <li>Remove Redundant Information: Eliminate any repetitive or unnecessary information that does not contribute to the context.</li> <li>Use Bullet Points: Convert detailed explanations into bullet points to make the information more compact.</li> <li>Combine Messages: Merge related messages into a single message to reduce the overall number of tokens.</li> <li>Focus on Relevant Context: Retain only the parts of the conversation that are directly relevant to the current interaction.</li> </ol> <p>By applying these strategies, you can maintain the essential context while minimizing the token usage in Chat Mode.</p> <p>Here is a Python example that condenses a conversation history by removing duplicate messages, adds a new user message, and calls the OpenAI Chat API with the updated conversation. The condensing strategy also includes selecting only the first sentence from each message to keep the conversation concise. </p> <pre><code>from azure.identity import DefaultAzureCredential\nfrom azure.ai.openai import OpenAIClient\n\n# Set up Azure OpenAI parameters\nAZURE_OPENAI_ENDPOINT = \"https://&lt;your Azure OpenAI endpoint&gt;.openai.azure.com/\"\nAZURE_OPENAI_API_KEY = \"&lt;your API Key&gt;\"\n\n# Initialize OpenAIClient\nclient = OpenAIClient(\n    endpoint=AZURE_OPENAI_ENDPOINT, \n    credential=AZURE_OPENAI_API_KEY\n)\n\n# Condense the conversation\ndef condense_conversation(conversation_history):\n    seen_contents = set()   # A set to store unique message contents\n    cleaned_history = []    # Cleaned conversation history\n\n    # Remove duplicate messages\n    for message in conversation_history:\n        if message['content'] not in seen_contents:\n            cleaned_history.append(message)\n            seen_contents.add(message['content'])\n\n    # Condensed by selecting the first sentence of each message\n    summary = \"\\n\".join(\n        msg['content'].split('.')[0] \n        for msg in cleaned_history \n        if msg['content']\n    )\n\n    # Create a condensed conversation by combining role and content\n    condensed_conversation = \"\\n\".join(\n        f\"{msg['role']}: {msg['content']}\" \n        for msg in cleaned_history\n    )    \n\n    return cleaned_history\n\n# Original conversation history\nconversation_history = [\n    {\n        \"role\": \"user\", \n        \"content\": \"Hello, I need some help with my account.\"\n    },\n    {\n        \"role\": \"assistant\", \n        \"content\": \"Sure, I can help you with your account. What seems to be the issue?\"\n    },\n    {\n        \"role\": \"user\", \n        \"content\": \"I forgot my password and cannot log in.\"\n    },\n    {\n        \"role\": \"assistant\", \n        \"content\": \"No problem, I can assist you with resetting your password.\"\n    },\n    {\n        \"role\": \"user\", \n        \"content\": \"I forgot my password and cannot log in.\"\n    }\n]\n\n# Get cleaned conversation\ncleaned_history = condense_conversation(conversation_history)\n\n# Add new conversation message\nnew_message = {\n    \"role\": \"user\", \n    \"content\": \"Can you tell me how long the reset process will take?\"\n}\ncleaned_history.append(new_message)\n\n# Call Azure OpenAI API with updated conversation\nresponse = client.chat_completions.create(\n    deployment_id=\"&lt;your deployment name&gt;\",\n    messages=cleaned_history,\n    max_tokens=50\n)\n\n# Get API response content\nresponse_content = response.choices[0].message[\"content\"].strip()\n\n# Display the response\nprint(response_content)\n</code></pre>"},{"location":"azure-openai/azure-openai/#4-azure-openai-vs-openais-api","title":"4. Azure OpenAI vs OpenAI\u2019s API","text":"<p>Azure OpenAI differs from OpenAI\u2019s ChatGPT API in these key aspects:</p> <ul> <li>Access: Azure OpenAI requires an Azure account and specific access permissions, while OpenAI\u2019s API is accessible directly through OpenAI\u2019s website.</li> <li>Integration: Azure OpenAI integrates seamlessly with other Azure services, such as Key Vault and Monitor.</li> <li>Enterprise Management: Azure OpenAI offers enterprise-grade features, including resource monitoring, network security, and compliance.</li> <li>Endpoint URL: Azure OpenAI uses a specific API URL format, like <code>https://&lt;your-azure-endpoint&gt;/openai/deployments/&lt;deployment-id&gt;/...</code>, and requires an <code>api-version</code> specification, whereas OpenAI\u2019s ChatGPT API uses a simpler endpoint structure like <code>https://api.openai.com/v1/...</code>.</li> <li>Deployment Management: In Azure OpenAI, each model requires setting up a \"deployment\" with a unique <code>deployment-id</code> identifier, while OpenAI's API directly specifies the model name without needing a separate deployment configuration.</li> </ul>"},{"location":"cli-tools/cli-with-python/","title":"CLI Tools with Python","text":""},{"location":"cli-tools/python-venv/","title":"Python venv Guide","text":""},{"location":"cli-tools/python-venv/#1-python-virtual-environments","title":"1. Python Virtual Environments","text":"<p>When developing Python projects, different projects may require different versions of the Python interpreter and dependencies. To avoid dependency conflicts between projects, we can use a virtual environment. A virtual environment is a self-contained Python runtime that allows each project to have its own independent dependencies, unaffected by other projects.</p> <p>Python's built-in <code>venv</code> module is a lightweight tool used to create virtual environments and manage project dependencies. It is easy to use, requires no additional external packages, and is an ideal choice for both beginners and experienced developers.</p>"},{"location":"cli-tools/python-venv/#2-virtual-environment-setup","title":"2. Virtual Environment Setup","text":"<p>To create a virtual environment, navigate to your project\u2019s root directory and run the following command:</p> <pre><code>python -m venv myenv\n</code></pre> <ul> <li><code>python</code>: This invokes the Python interpreter.</li> <li><code>-m venv</code>: Uses the built-in <code>venv</code> module to create a virtual environment.</li> <li><code>myenv</code>: This is the name of the virtual environment. You can replace it with any appropriate name.</li> </ul> <p>Once the command is executed, a directory named <code>myenv</code> will be created in the current directory, containing an isolated Python interpreter and a dedicated environment for installing packages.</p> <p>Example</p> <p>Let's say you want to set up a virtual environment for a project named <code>my_project</code>. Here's how you can create it:</p> <pre><code>python -m venv my_project_env\n</code></pre> <p>This creates a new virtual environment in a folder named <code>my_project_env</code>.</p>"},{"location":"cli-tools/python-venv/#3-activedeactivate-venv","title":"3. Active/Deactivate venv","text":""},{"location":"cli-tools/python-venv/#31-activating","title":"3.1 Activating","text":"<p>The activation process differs based on your operating system:</p> <ul> <li> <p>Windows:   <code>bash   myenv\\Scripts\\activate</code></p> </li> <li> <p>Linux/macOS:   <code>bash   source myenv/bin/activate</code></p> </li> </ul> <p>After activation, your terminal prompt will change to indicate that the virtual environment is active, typically showing something like <code>(myenv)</code> before the command prompt.</p>"},{"location":"cli-tools/python-venv/#32-deactivating","title":"3.2 Deactivating","text":"<p>To deactivate the virtual environment and return to the global Python environment, run the following command:</p> <pre><code>deactivate\n</code></pre> <p>Once deactivated, the terminal prompt will return to normal, and the global Python environment will no longer be affected by the virtual environment's packages.</p>"},{"location":"cli-tools/python-venv/#4-benefits-of-using-venv","title":"4. Benefits of Using venv","text":""},{"location":"cli-tools/python-venv/#41-environment-isolation","title":"4.1 Environment Isolation","text":"<p>One of the key benefits of <code>venv</code> is that it isolates the Python environment for each project. This prevents package version conflicts between projects. For example, one project may require version 2.x of the <code>requests</code> library, while another project might need version 3.x. Using virtual environments ensures that each project uses the correct version without interference.</p>"},{"location":"cli-tools/python-venv/#42-easy-management","title":"4.2 Easy Management","text":"<p><code>venv</code> is part of Python\u2019s standard library, making it easy to use without requiring any external tools. Creating and removing virtual environments is straightforward, and each environment is self-contained, simplifying dependency management.</p>"},{"location":"cli-tools/python-venv/#43-multiple-python-versions","title":"4.3 Multiple Python Versions","text":"<p>With <code>venv</code>, you can maintain multiple Python environments with different versions of Python on the same machine. For example, you can create one environment with Python 3.8 and another with Python 3.10 to test how your code behaves across different Python versions.</p> <p>Example: Managing Multiple Python Versions</p> <p>You can specify the Python version when creating a virtual environment. If you want to use Python 3.8, you could run:</p> <pre><code>python3.8 -m venv myenv38\n</code></pre> <p>Similarly, for Python 3.10:</p> <pre><code>python3.10 -m venv myenv310\n</code></pre> <p>Each virtual environment will have its own Python interpreter and libraries.</p>"},{"location":"cli-tools/python-venv/#5-tips-and-best-practices","title":"5. Tips and Best Practices","text":"<p>When working with Python virtual environments, it's essential to follow best practices to ensure a smooth development experience and avoid common pitfalls.</p>"},{"location":"cli-tools/python-venv/#51-common-issues","title":"5.1 Common Issues","text":"<ul> <li> <p>Issue: On Windows, when trying to activate a virtual environment using PowerShell, you might encounter an error related to the \"execution policy restriction.\" This error occurs because PowerShell has built-in security settings that prevent the execution of scripts by default, including activation scripts for Python virtual environments.</p> </li> <li> <p>Solution: To resolve this, you need to modify PowerShell\u2019s execution policy, which controls the conditions under which scripts are allowed to run. The following command adjusts the policy to allow locally created scripts to run:</p> </li> </ul> <p><code>powershell   Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser</code></p> <p>Explanation of the command parameters:</p> <ul> <li> <p><code>Set-ExecutionPolicy</code>: This is the PowerShell command used to change the current execution policy, which governs how and when scripts can be run on your system.</p> </li> <li> <p><code>-ExecutionPolicy RemoteSigned</code>: This parameter sets the execution policy to <code>RemoteSigned</code>. It means that scripts created on your local machine can be run without a signature, but any scripts downloaded from the internet (considered \"remote\") must be digitally signed by a trusted publisher. This provides a balance between allowing local development scripts and maintaining some security for remote content.</p> </li> <li> <p><code>-Scope CurrentUser</code>: This limits the execution policy change to the current user\u2019s profile, meaning it will only affect your user account and not the entire system. This is a safer and more controlled approach than changing the execution policy system-wide, which could affect other users or services on the same machine.</p> </li> </ul> <p>After running this command, PowerShell will allow you to activate your Python virtual environments without encountering the \"execution policy restriction\" error, while still providing some protection for scripts obtained from external sources.</p>"},{"location":"cli-tools/python-venv/#52-best-practices","title":"5.2 Best Practices","text":"<ul> <li> <p>Use a dedicated virtual environment for each project: This ensures isolation between projects and prevents dependency conflicts.</p> </li> <li> <p>Exclude virtual environments from version control: It's a good idea to add the virtual environment directory (e.g., <code>myenv/</code>) to your <code>.gitignore</code> file to prevent committing large, unnecessary files to your repository. Example <code>.gitignore</code> entry:   <code>myenv/</code></p> </li> </ul>"},{"location":"cli-tools/python-venv/#6-example-workflow","title":"6. Example Workflow","text":"<p>Example: Setting Up and Using a Virtual Environment</p> <p>Suppose you are working on a project that requires Python 3.9 and two libraries: <code>requests</code> and <code>flask</code>. You can follow these steps:</p> <ol> <li> <p>Create the virtual environment:    <code>bash    python3.9 -m venv myenv</code></p> </li> <li> <p>Activate the virtual environment:</p> </li> <li>Linux/macOS:      <code>bash      source myenv/bin/activate</code></li> <li> <p>Windows:      <code>bash      myenv\\Scripts\\activate</code></p> </li> <li> <p>Install the required dependencies:    With the environment activated, you can use <code>pip</code> to install the libraries:    <code>bash    pip install requests flask</code></p> </li> <li> <p>Verify installed packages:    To check the installed packages, use:    <code>bash    pip list</code>    This command will show all installed packages in the virtual environment along with their versions.</p> </li> <li> <p>Save dependencies:    To allow other developers to replicate your environment, you can save the current dependencies to a <code>requirements.txt</code> file:    <code>bash    pip freeze &gt; requirements.txt</code></p> </li> <li> <p>Deactivate the virtual environment:    Once you're done with your work, deactivate the environment with:    <code>bash    deactivate</code></p> </li> </ol>"},{"location":"cli-tools/python-venv/#7-conclusion","title":"7. Conclusion","text":"<p>Using <code>venv</code> to manage Python environments is a simple and effective way to ensure project isolation and consistency. It is suitable for small-scale projects and individual developers. Additionally, by reducing the complexity of environment setup, it enhances collaboration with other developers and improves overall project stability and development efficiency.</p>"}]}